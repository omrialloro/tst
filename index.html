<!doctype html>
<html lang="he">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Veg Duel (Per-Player Deck)</title>
  <style>
    :root{
      --border:#2a3345;
      --shadow: 0 10px 30px rgba(0,0,0,0.35);
      --muted: rgba(255,255,255,0.65);
    }
    *{ box-sizing:border-box; }
    body{
      margin:0;
      min-height:100vh;
      background:linear-gradient(180deg,#0b0d12,#0f1116);
      font-family:system-ui, -apple-system, Segoe UI, Roboto, Arial;
      color:#fff;
    }

    .layout{
      min-height:100vh;
      display:flex;
      gap:14px;
      padding:14px;
      align-items:center;
      justify-content:center;
    }

    /* Left side: two baskets */
    .left{
      width:190px;
      display:flex;
      flex-direction:column;
      gap:12px;
      align-self:stretch;
      justify-content:center;
    }
    .turn{
      padding:10px 12px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(0,0,0,0.28);
      backdrop-filter: blur(6px);
      box-shadow: var(--shadow);
      font-weight:900;
      letter-spacing:0.2px;
      color:rgba(255,255,255,0.92);
    }
    .turn small{
      display:block;
      margin-top:4px;
      font-weight:700;
      font-size:12px;
      color:var(--muted);
      letter-spacing:0;
    }

    .basket{
      border-radius:18px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(0,0,0,0.28);
      backdrop-filter: blur(6px);
      box-shadow: var(--shadow);
      padding:10px;
      height:220px;
      overflow:auto;
      scrollbar-width:none;
    }
    .basket::-webkit-scrollbar{ display:none; }

    .basketTitle{
      font-weight:900;
      font-size:13px;
      color:rgba(255,255,255,0.85);
      margin-bottom:10px;
      display:flex;
      align-items:center;
      justify-content:space-between;
    }
    .count{
      font-weight:900;
      font-size:12px;
      color:rgba(255,255,255,0.6);
      border:1px solid rgba(255,255,255,0.12);
      background:rgba(255,255,255,0.06);
      padding:4px 8px;
      border-radius:999px;
    }

    .grid{
      display:grid;
      grid-template-columns: repeat(2, minmax(0, 1fr));
      gap:10px;
    }
    .grid img{
      width:100%;
      aspect-ratio:1/1;
      border-radius:16px;
      border:1px solid rgba(255,255,255,0.16);
      background:rgba(255,255,255,0.06);
      object-fit:cover;
      box-shadow: 0 10px 18px rgba(0,0,0,0.25);
      transform: translateY(0);
      transition: transform 160ms ease;
    }
    .grid img.pop{ transform: translateY(-6px) scale(1.02); }

    /* Center map */
    .center{
      display:grid;
      place-items:center;
      align-self:stretch;
      flex:1;
    }
    .wrap{
      position:relative;
      width:min(92vmin, 900px);
      aspect-ratio: 1 / 1;
      border-radius:18px;
      overflow:hidden;
      border:1px solid var(--border);
      box-shadow: var(--shadow);
      background:#0b0d12;
      user-select:none;
    }
    .wrap img.map{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
      pointer-events:none;
    }
    canvas{
      position:absolute;
      inset:0;
      width:100%;
      height:100%;
    }

    /* Target: top-right (outside map) */
    .targetWrap{
      position:fixed;
      top:14px;
      right:14px;
      width:110px;
      display:flex;
      flex-direction:column;
      align-items:center;
      gap:8px;
      pointer-events:none;
      z-index:10;
    }
    .target{
      width:100px;
      height:100px;
      border-radius:16px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(255,255,255,0.06);
      object-fit:cover;
      box-shadow: 0 14px 35px rgba(0,0,0,0.45);
    }
    .targetName{
      width:110px;
      text-align:center;
      font-weight:900;
      font-size:13px;
      color:rgba(255,255,255,0.9);
      padding:8px 10px;
      border-radius:999px;
      border:1px solid rgba(255,255,255,0.14);
      background:rgba(0,0,0,0.28);
      backdrop-filter: blur(6px);
      box-shadow: var(--shadow);
    }

    /* Reveal near click (inside map) */
    .reveal{
      position:absolute;
      width:150px;
      height:150px;
      border-radius:18px;
      border:1px solid rgba(255,255,255,0.18);
      background:rgba(0,0,0,0.25);
      object-fit:cover;
      box-shadow: 0 18px 60px rgba(0,0,0,0.55);
      opacity:0;
      transform: scale(0.96);
      pointer-events:none;
      transition: opacity 120ms ease, transform 120ms ease;
    }
    .reveal.on{ opacity:1; transform: scale(1); }

    /* Failure feedback: red flash + shake */
    .flash{
      position:absolute;
      inset:0;
      pointer-events:none;
      opacity:0;
      transition: opacity 120ms ease;
    }
    .flash.on{ opacity:1; }
    .shake{ animation: shake 180ms ease; }
    @keyframes shake{
      0%{ transform: translateX(0); }
      25%{ transform: translateX(-6px); }
      50%{ transform: translateX(6px); }
      75%{ transform: translateX(-4px); }
      100%{ transform: translateX(0); }
    }

    /* Win overlay */
    .win{
      position:fixed;
      inset:0;
      display:none;
      align-items:center;
      justify-content:center;
      background:rgba(0,0,0,0.55);
      backdrop-filter: blur(6px);
      z-index:50;
    }
    .winCard{
      width:min(76vmin, 520px);
      aspect-ratio: 1 / 1;
      border-radius:22px;
      overflow:hidden;
      border:1px solid rgba(255,255,255,0.16);
      background:rgba(255,255,255,0.06);
      box-shadow: 0 20px 60px rgba(0,0,0,0.5);
      position:relative;
    }
    .winCard img{
      width:100%;
      height:100%;
      object-fit:cover;
      display:block;
    }
    .winLabel{
      position:absolute;
      top:14px;
      left:14px;
      right:14px;
      padding:12px 14px;
      border-radius:18px;
      background:rgba(0,0,0,0.35);
      border:1px solid rgba(255,255,255,0.14);
      color:rgba(255,255,255,0.92);
      font-weight:900;
      font-size:18px;
      text-align:center;
    }

    @media (max-width: 820px){
      .layout{ flex-direction:column; }
      .left{ width:min(92vmin, 520px); flex-direction:row; align-self:auto; }
      .basket{ height:170px; flex:1; }
      .turn{ width:100%; }
    }
  </style>
</head>
<body>
  <div class="targetWrap">
    <img class="target" id="targetImg" alt="target"/>
    <div class="targetName" id="targetName"></div>
  </div>

  <div class="layout">
    <aside class="left">
      <div class="turn" id="turnLabel">×©×—×§×Ÿ ×<small>×”×ª×•×¨ ×©×œ×š</small></div>

      <div class="basket">
        <div class="basketTitle">
          <span>×©×—×§×Ÿ ×</span>
          <span class="count" id="countA">0</span>
        </div>
        <div class="grid" id="gridA"></div>
      </div>

      <div class="basket">
        <div class="basketTitle">
          <span>×©×—×§×Ÿ ×‘</span>
          <span class="count" id="countB">0</span>
        </div>
        <div class="grid" id="gridB"></div>
      </div>
    </aside>

    <main class="center">
      <div class="wrap" id="wrap">
        <img class="map" src="map.png" alt="map"/>
        <canvas id="c"></canvas>

        <img class="reveal" id="revealImg" alt="reveal"/>
        <div class="flash" id="flash"></div>
      </div>
    </main>
  </div>

  <div class="win" id="win">
    <div class="winCard">
      <div class="winLabel" id="winLabel">â€”</div>
      <img src="×¡×œ×˜.jpg" alt="salad"/>
    </div>
  </div>

<script>
(() => {
  const wrap = document.getElementById('wrap');
  const canvas = document.getElementById('c');
  const ctx = canvas.getContext('2d');

  const targetImg = document.getElementById('targetImg');
  const targetName = document.getElementById('targetName');
  const turnLabel = document.getElementById('turnLabel');

  const gridA = document.getElementById('gridA');
  const gridB = document.getElementById('gridB');
  const countA = document.getElementById('countA');
  const countB = document.getElementById('countB');

  const revealImg = document.getElementById('revealImg');
  const flash = document.getElementById('flash');

  const win = document.getElementById('win');
  const winLabel = document.getElementById('winLabel');

  const EXT = "jpg";
  const cropToFile = (name) => encodeURI(`${name}.${EXT}`);

  let DATA = null;
  let points = [];
  let hoverId = null;

  let allCrops = [];
  let targetCrop = null;

  const P_A = 0, P_B = 1;
  let currentPlayer = P_A;

  // âœ… each player has their own collected set
  const collectedBy = [new Set(), new Set()];
  let gameOver = false;

  let revealTimer = null;

  function setTurnUI(){
    turnLabel.innerHTML = (currentPlayer === P_A)
      ? `×©×—×§×Ÿ ×<small>×”×ª×•×¨ ×©×œ×š</small>`
      : `×©×—×§×Ÿ ×‘<small>×”×ª×•×¨ ×©×œ×š</small>`;
  }

  function updateCounts(){
    countA.textContent = String(collectedBy[P_A].size);
    countB.textContent = String(collectedBy[P_B].size);
  }

  // âœ… crops missing for a specific player
  function missingFor(player){
    const have = collectedBy[player];
    return allCrops.filter(c => !have.has(c));
  }

  // âœ… target is always from crops missing for CURRENT player
  function pickTargetForCurrentPlayer(){
    const miss = missingFor(currentPlayer);

    if (miss.length === 0) {
      // this player already completed set -> win should already be triggered
      targetCrop = null;
      targetImg.removeAttribute('src');
      targetName.textContent = "";
      return;
    }

    const idx = Math.floor(Math.random() * miss.length);
    targetCrop = miss[idx];
    targetImg.src = cropToFile(targetCrop);
    targetImg.onerror = () => targetImg.removeAttribute('src');
    targetName.textContent = targetCrop;
  }

  function resizeCanvas() {
    const rect = wrap.getBoundingClientRect();
    const dpr = Math.max(1, window.devicePixelRatio || 1);
    canvas.width = Math.round(rect.width * dpr);
    canvas.height = Math.round(rect.height * dpr);
    ctx.setTransform(dpr, 0, 0, dpr, 0, 0);
    draw();
  }

  function imgToCss(xImg, yImg) {
    const rect = wrap.getBoundingClientRect();
    const sx = rect.width  / DATA.imageSize.width;
    const sy = rect.height / DATA.imageSize.height;
    return { x: xImg * sx, y: yImg * sy };
  }

  function hitTest(mx, my) {
    const R = 14;
    let best = null;
    let bestD = Infinity;
    for (const p of points) {
      const pos = imgToCss(p.x, p.y);
      const d = Math.hypot(mx - pos.x, my - pos.y);
      if (d < R && d < bestD) { best = p; bestD = d; }
    }
    return best;
  }

  function draw() {
    if (!DATA) return;
    const rect = wrap.getBoundingClientRect();
    ctx.clearRect(0, 0, rect.width, rect.height);

    for (const p of points) {
      const {x, y} = imgToCss(p.x, p.y);
      const isHover = hoverId === p.id;

      let fill = 'rgba(232,238,252,0.75)';
      if (p.crops.length === 0) fill = 'rgba(232,238,252,0.22)';

      if (isHover) {
        ctx.beginPath();
        ctx.arc(x, y, 16, 0, Math.PI * 2);
        ctx.fillStyle = 'rgba(106,166,255,0.14)';
        ctx.fill();
        ctx.lineWidth = 2;
        ctx.strokeStyle = 'rgba(106,166,255,0.65)';
        ctx.stroke();
      }

      ctx.beginPath();
      ctx.arc(x, y, 7, 0, Math.PI * 2);
      ctx.fillStyle = fill;
      ctx.fill();
      ctx.lineWidth = 1.5;
      ctx.strokeStyle = 'rgba(42,51,69,1)';
      ctx.stroke();
    }
  }

  function addToBasket(player, cropName){
    const img = document.createElement('img');
    img.alt = cropName;
    img.src = cropToFile(cropName);
    img.onerror = () => img.remove();

    const grid = (player === P_A) ? gridA : gridB;
    grid.appendChild(img);

    requestAnimationFrame(() => img.classList.add('pop'));
    setTimeout(() => img.classList.remove('pop'), 180);

    updateCounts();
  }

  function flashFail(){
    flash.style.background = 'rgba(255,93,102,0.16)';
    flash.classList.add('on');
    setTimeout(() => flash.classList.remove('on'), 140);

    wrap.classList.remove('shake');
    void wrap.offsetWidth;
    wrap.classList.add('shake');
    setTimeout(() => wrap.classList.remove('shake'), 200);
  }
  function flashSuccess(){
    flash.style.background = 'rgba(68,255,154,0.12)';
    flash.classList.add('on');
    setTimeout(() => flash.classList.remove('on'), 140);
  }

  function showRevealNearPoint(cropName, cssX, cssY){
    if (!cropName) return;
    if (revealTimer) clearTimeout(revealTimer);

    const rect = wrap.getBoundingClientRect();
    const w = 150, h = 150;

    let left = cssX + 14;
    let top  = cssY - h - 14;

    left = Math.max(8, Math.min(left, rect.width  - w - 8));
    top  = Math.max(8, Math.min(top,  rect.height - h - 8));

    revealImg.style.left = left + "px";
    revealImg.style.top  = top  + "px";

    revealImg.src = cropToFile(cropName);
    revealImg.onerror = () => {};

    revealImg.classList.add('on');
    revealTimer = setTimeout(() => revealImg.classList.remove('on'), 1000);
  }

  function checkWin(player){
    if (collectedBy[player].size === allCrops.length) {
      gameOver = true;
      win.style.display = 'flex';
      winLabel.textContent = (player === P_A) ? '×©×—×§×Ÿ × × ×™×¦×— ğŸ¥—' : '×©×—×§×Ÿ ×‘ × ×™×¦×— ğŸ¥—';
    }
  }

  async function load() {
    const res = await fetch('annotation.json', { cache: 'no-store' });
    const json = await res.json();

    DATA = json;
    points = (DATA.annotations || []).map(a => ({
      ...a,
      crops: Array.isArray(a.crops) ? a.crops : []
    }));

    const set = new Set();
    for (const p of points) for (const c of p.crops) set.add(c);
    allCrops = [...set];

    updateCounts();
    resizeCanvas();
    setTurnUI();
    pickTargetForCurrentPlayer();
  }

  // interactions
  wrap.addEventListener('mousemove', (e) => {
    if (!DATA || gameOver) return;
    const r = wrap.getBoundingClientRect();
    const mx = e.clientX - r.left;
    const my = e.clientY - r.top;
    const hit = hitTest(mx, my);
    const newHover = hit ? hit.id : null;
    if (newHover !== hoverId) { hoverId = newHover; draw(); }
  });

  wrap.addEventListener('mouseleave', () => {
    hoverId = null;
    draw();
  });

  wrap.addEventListener('click', (e) => {
    if (!DATA || !targetCrop || gameOver) return;

    const r = wrap.getBoundingClientRect();
    const mx = e.clientX - r.left;
    const my = e.clientY - r.top;
    const hit = hitTest(mx, my);
    if (!hit) return;

    // reveal "hidden there" (first crop)
    const hidden = (hit.crops && hit.crops.length) ? hit.crops[0] : null;
    showRevealNearPoint(hidden, mx, my);

    // correct = this spot contains the target crop
    const match = hit.crops.includes(targetCrop);

    if (match) {
      flashSuccess();

      // award only if this player doesn't already have it
      if (!collectedBy[currentPlayer].has(targetCrop)) {
        collectedBy[currentPlayer].add(targetCrop);
        addToBasket(currentPlayer, targetCrop);
      }

      checkWin(currentPlayer);
      if (gameOver) return;

      // âœ… correct => same player continues, target from THEIR missing set
      pickTargetForCurrentPlayer();
    } else {
      flashFail();

      // wrong => switch player
      currentPlayer = (currentPlayer === P_A) ? P_B : P_A;
      setTurnUI();

      // âœ… new target from the new player's missing set
      pickTargetForCurrentPlayer();
    }
  });

  window.addEventListener('resize', resizeCanvas);

  resizeCanvas();
  load().catch(() => {});
})();
</script>
</body>
</html>
